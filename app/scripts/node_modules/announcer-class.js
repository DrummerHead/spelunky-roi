'use strict';

/**
 * Exports Announcer constructor
 *
 * @module announcer-class
 */


var _ = require('lodash');

/**
 * The announcer handles communication between the other object instances. It
 * gets passed as a parameter on initialization.
 *
 * @constructor Announcer
 * @requires module:lodash
 */
var Announcer = function(){
  this.data = {};
};

/**
 * Search this.data for specific entry
 *
 * @param {string} category
 * @param {string} id
 * @returns {object|undefined} reference to found object
 * @see https://lodash.com/docs#find
 */
Announcer.prototype.findData = function(category, id){
  return _.find(this.data[category], function(previous){
    return previous.id === id;
  });
};

/**
 * @typedef publishData
 * @type Object
 * @property {string} category - Type of object to be subscribed
 * @property {string} id - Object ID (sometimes name is used as ID)
 * @property {object|number} data - Object to subscribe or data to store
 */

/**
 * Used by host objects to publish themselves or data to Announcer instance
 * Calls [announcements method]{@link module:announcer-class~Announcer#announcements}
 *
 * @param {object} me - [publishData]{@link module:announcer-class~publishData} object
 */
Announcer.prototype.publish = function(me){
  if(!this.data.hasOwnProperty(me.category)){
    this.data[me.category] = [];
  }

  var previousData = this.findData(me.category, me.id);

  if(previousData){
    _.assign(previousData, me);
  }
  else {
    this.data[me.category].push(me);
  }

  this.announcements(me);

};

/**
 * Specific announcements, supposed to be more application specific than the
 * generic Announcer specification
 *
 * @param {object} subject - [publishData]{@link module:announcer-class~publishData} object
 * @todo perhaps I should define this method in the instance of Announcer to
 * make the class more generic
 */
Announcer.prototype.announcements = function(subject){
  if(subject.category === 'number'){
    var i, l, newPrice;
    var area = this.findData('number', 'area') || {data: 1};
    var level = this.findData('number', 'level') || {data: 1};

    for(i = 0, l = this.data.consumable.length; i < l; i++){
      newPrice = this.data.consumable[i].data.updatePrice(area.data, level.data);
      this.data.accountant[0].data.updatePrice(
        {
          category: 'investments',
          id: this.data.consumable[i].data.name,
          number: newPrice
        }
      );
    }
    if(subject.id === 'area'){
      for(i = 0, l = this.data.treasure.length; i < l; i++){
        newPrice = this.data.treasure[i].data.updatePrice(area.data);
        this.data.accountant[0].data.updatePrice(
          {
            category: 'profits',
            id: this.data.treasure[i].data.name,
            number: newPrice
          }
        );
      }
    }
  }
};

/**
 * Bridge method between consumable and accountant
 *
 * @param {object} data
 * @param {string} data.id consumable id
 * @param {number} data.calculatedPrice consumable price
 */
Announcer.prototype.invest = function(data){
  this.data.accountant[0].data.invest(data);
};

/**
 * Bridge method between treasure and accountant
 *
 * @param {object} data
 * @param {string} data.id treasure id
 * @param {number} data.calculatedPrice treasure price
 */
Announcer.prototype.profit = function(data){
  this.data.accountant[0].data.profit(data);
};


module.exports = Announcer;
